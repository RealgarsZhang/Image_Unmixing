#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <cuda.h>

#include "magma.h"
#include "magma_lapack.h"

#include"NoNoiseNoPrintMagma.h"

double tanh(double x){
    return (exp(x)-exp(-x))/(exp(x)+exp(-x));
 
}

double random_generate(double min, double max){
    double returnValue;
    returnValue = (double)rand()/(double)RAND_MAX;
    returnValue = min + (max-min)* returnValue;
    return returnValue;   

}
/**************************************************
  Description: readinExamples() reads in the examples 
generated by matlab.For each set of training examles,
both the examples image and the coeffcients for the 
three basic modes are provided.
  Return value: 0 if some error, 1 if everything ok.

  NOTE: You should pass the address of the matrix
        Don't malloc space of the matrix! This is 
	done in this function!!!

	All arguments are allocated and NOT freed.
************************************************/
int readinExamples(MATRIX* ptr_coefMatrix_train,
                    MATRIX* ptr_coefMatrix_cv,
                    MATRIX* ptr_coefMatrix_test,
                    MATRIX* ptr_examples_train,
                    MATRIX* ptr_examples_cv,
                    MATRIX* ptr_examples_test){
    FILE* fileInput;
    int row,col;
    int temp_size;
    int i;
    int err;
    double temp;
    
    
 
   //readin coefMatrix_train
    fileInput = fopen("./examples/coefMatrix_train","r");
    if ( fileInput == NULL ){
        printf( "Unable to open the file!\n" );
	return (0);
    }
    
    fscanf(fileInput, "%d %d", &row, &col);
    //printf("row:%d col:%d\n", row, col);
    ptr_coefMatrix_train->row = row;
    ptr_coefMatrix_train->col = col;
    ptr_coefMatrix_train->data= (double*)malloc(sizeof(double)*row*col);
    
    i = 0;
    temp_size = row*col;
    while(i < temp_size) {
 	fscanf( fileInput, "%lf", &temp );
        //printf("num:%lf\n", temp);
        ptr_coefMatrix_train->data[i] = temp;
        i++;
   }
    fclose( fileInput );
    
    //read coefMatrix_cv
    fileInput = fopen("./examples/coefMatrix_cv","r");
    if ( fileInput == NULL ){
        printf( "Unable to open the file!\n" );
	return (0);
    }

    fscanf(fileInput, "%d %d", &row, &col);
    ptr_coefMatrix_cv->row = row;
    ptr_coefMatrix_cv->col = col;
   // ptr_coefMatrix_cv->data= (double*)malloc(sizeof(double)*row*col);
    ptr_coefMatrix_cv->data= (double*)malloc(sizeof(double)*row*col);
    //printf("row:%d col:%d\n", row, col);    
   
    i = 0;

    temp_size = row*col;
    while(i < temp_size) {
 	fscanf( fileInput, "%lf", &temp );
    //    printf("num:%lf\n", temp);
        ptr_coefMatrix_cv->data[i] = temp;
        i++;
   }

    fclose( fileInput );
    
    //read in coefMatrix_test
    fileInput = fopen("./examples/coefMatrix_test","r");
    if ( fileInput == NULL ){
        printf( "Unable to open the file!\n" );
	return (0);
    }

    fscanf(fileInput, "%d %d", &row, &col);
    ptr_coefMatrix_test->row = row;
    ptr_coefMatrix_test->col = col;
    ptr_coefMatrix_test->data= (double*)malloc(sizeof(double)*row*col);
    //ptr_coefMatrix_test->data= (double*)malloc(sizeof(double)*row*col);
    //printf("row:%d col:%d\n", row, col); 
    i = 0;
    temp_size = row*col;
    while(i < temp_size) {
 	fscanf( fileInput, "%lf", &temp );
    //    printf("num:%lf\n", temp);
        ptr_coefMatrix_test->data[i] = temp;
        i++;
   }

    fclose( fileInput );
 
 
    fileInput = fopen("./examples/examples_train","r");
    if ( fileInput == NULL ){
        printf( "Unable to open the file!\n" );
	return (0);
    }

    fscanf(fileInput, "%d %d", &row, &col);
    ptr_examples_train->row = row;
    ptr_examples_train->col = col;
    ptr_examples_train->data= (double*)malloc(sizeof(double)*row*col);
    //ptr_examples_train->data= (double*)malloc(sizeof(double)*tempsize);
    //printf("row:%d col:%d\n", row, col);
    i = 0;
    temp_size = row*col;
    while(i < temp_size) {
        fscanf( fileInput, "%lf", &temp );
    //    printf("num:%lf\n", temp);
        ptr_examples_train->data[i] = temp;
        i++;
   }

    fclose( fileInput );
 
    fileInput = fopen("./examples/examples_cv","r");
    if ( fileInput == NULL ){
        printf( "Unable to open the file!\n" );
	return (0);
    }

    fscanf(fileInput, "%d %d", &row, &col);
    ptr_examples_cv->row = row;
    ptr_examples_cv->col = col;
    ptr_examples_cv->data= (double*)malloc(sizeof(double)*row*col);
    //ptr_examples_cv->data= (double*)malloc(sizeof(double)*tempsize);
    //printf("row:%d col:%d\n", row, col);
    i = 0;
    temp_size = row*col;
    while(i < temp_size) {
        fscanf( fileInput, "%lf", &temp );
        //printf("num%d:%lf\n",i, temp);
        ptr_examples_cv->data[i] = temp;
        i++;
   }

    fclose( fileInput );

    fileInput = fopen("./examples/examples_test","r");
    if ( fileInput == NULL ){
        printf( "Unable to open the file!\n" );
	return (0);
    }

    fscanf(fileInput, "%d %d", &row, &col);
    ptr_examples_test->row = row;
    ptr_examples_test->col = col;
    ptr_examples_test->data= (double*)malloc(sizeof(double)*row*col);
    //ptr_examples_test->data= (double*)malloc(sizeof(double)*tempsize);
    //printf("row:%d col:%d\n", row, col);
    i = 0;
    temp_size = row*col;
    while(i < temp_size) {
        fscanf( fileInput, "%lf", &temp );
    //    printf("num:%lf\n", temp);
        ptr_examples_test->data[i] = temp;
        i++;
   }
    printf("Examples successfully read in!\n");
    fclose( fileInput );
    return (1);
}
/***************************************************
    Description: padOne() add a row where all entries are
  1 to the top of a matrix d_A. Return a MATRIX struct
    Detail: 1.Make an all-one row on CPU,
            2.magma_dmalloc() a matrix on GPU ,with the row = d_A.row+1,
            3.copy the data of d_A to the submatrix of the returnMatrix,
            4.dset and copy the all-one row to the top row of returnMatrix.
    NOTE : magma_dmalloc() is called here,to allocate space for the 
  new matrix.
****************************************************/
MATRIX padOne(MATRIX d_A){
    MATRIX returnMatrix;
    int i,j,mallocSize;
    int err;
    double *allOneArray; 
    double *d_allOneArray;
   
    allOneArray = (double*) malloc(sizeof(double)*d_A.col);
    for( i=0 ; i<d_A.col ; i++){
        allOneArray[i] = 1.0;
    }
    magma_dmalloc ( &d_allOneArray , d_A.col );
    magma_dsetvector(   d_A.col ,
                        allOneArray , 1 ,
                      d_allOneArray , 1 );
    
                                          
    
    returnMatrix.col = d_A.col;
    returnMatrix.row = d_A.row + 1;
    mallocSize = returnMatrix.col * returnMatrix.row;
       

    magma_dmalloc ( &(returnMatrix.data) , mallocSize );
    magmablas_dlacpy ( MagmaFull , 
                       d_A.row   ,
		       d_A.col   ,
		       d_A.data  ,
		       d_A.row   ,
                       returnMatrix.data + 1 ,
		       returnMatrix.row );

    magmablas_dlacpy ( MagmaFull ,
                       1         ,
		       d_A.col   ,
                       d_allOneArray ,
		       1         ,
		       returnMatrix.data,
		       returnMatrix.row );

     
    free(allOneArray);
    magma_free(d_allOneArray);
    return returnMatrix;	   
}
/***************************************************************
 * the remove_top_row removes the top row of a matrix. A pointer to this matrix    is passed to the function.Principally, this function is only used in trimming the delta in backpropogation.
 ***************************************************************/

void remove_top_row(MATRIX* ptr_delta){
    
    int mallocSize; 
    double* tempArray, *temp;
    int i, j, k1, k2;
    mallocSize = (ptr_delta->row - 1) * ptr_delta->col;
    tempArray = (double*)malloc(sizeof(double)* mallocSize );
    int k = 0;
    for( j=0; j<ptr_delta->col; j++)	
        for( i=1; i<ptr_delta->row; i++){
           k1 = j * ptr_delta->row + i;
	   k2 = j * (ptr_delta->row-1) + i - 1;
	   tempArray[k2] = ptr_delta->data[k1];
    } 
    temp = ptr_delta->data;
    ptr_delta->data = tempArray;
    free(temp);
    ptr_delta->row -= 1;
}


void apply_activation_function( MATRIX temp ){
    int ii;
    int mallocSize;
    double *cpuArray;

    mallocSize = temp.row*temp.col ;
    cpuArray = (double*) malloc(sizeof(double)* mallocSize );
    magma_dgetmatrix ( temp.row ,
                       temp.col ,
		       temp.data, 
		       temp.row ,
		       cpuArray ,
		       temp.row );
    
    for( ii=0 ; ii<mallocSize ; ii++ ){
        cpuArray[ii] = tanh( cpuArray[ii] );
    }
    
    magma_dsetmatrix ( temp.row , 
                       temp.col , 
		       cpuArray , 
		       temp.row ,
		       temp.data,
		       temp.row );
    free(cpuArray);

}

void apply_diff_activation_function( MATRIX temp ){
    int ii;
    int mallocSize;
    double *cpuArray;

    mallocSize = temp.row*temp.col ;
    cpuArray = (double*) malloc(sizeof(double)* mallocSize );
    magma_dgetmatrix ( temp.row ,
                       temp.col ,
		       temp.data, 
		       temp.row ,
		       cpuArray ,
		       temp.row );
    
    for( ii=0 ; ii<mallocSize ; ii++ ){
        cpuArray[ii] =  1.0 - cpuArray[ii]*cpuArray[ii] ;
    }
    
    magma_dsetmatrix ( temp.row , 
                       temp.col , 
		       cpuArray , 
		       temp.row ,
		       temp.data,
		       temp.row );
    free(cpuArray);

}
void pointwise_mult_and_apply_diff_activation(MATRIX d_delta,MATRIX d_a){
    int i;
    double *cpu_delta,*cpu_a;
    int vectorLength;
    vectorLength = d_delta.row*d_delta.col;

    cpu_delta = (double*) malloc(sizeof(double)*vectorLength);
    cpu_a     = (double*) malloc(sizeof(double)*vectorLength);

    magma_dgetvector( vectorLength,
                      d_delta.data,
		      1           ,
		      cpu_delta   ,
		      1           );


    magma_dgetvector( vectorLength,
                      d_a.data    ,
                      1           ,
                      cpu_a       ,
                      1           );

    for( i=0 ; i<vectorLength ; i++){
        cpu_delta[i] *= ( 1 - cpu_a[i]*cpu_a[i] );
    }

    magma_dsetvector ( vectorLength,
                       cpu_delta    , 
                       1            ,
      		       d_delta.data ,
		       1            );
    free(cpu_delta);
    free(cpu_a);
}

/**************************************************
 *     Description: costFunction computes the value of the cost function,
 *   as well as the gradient. The return value will be the value and the
 *   argument grad will store the gradient, which is unrolled according to 
 *   the "d_Theta(:)" in matlab.
 *     NOTE : This function will NOT malloc for grad !
 *     ****************************************************/
double costFunction ( double* d_grad,
                      double* d_nn_params,
                      MATRIX* d_a,//keep the top rows of d_a at all costs!
		      const int input_layer_size,
                      const int hidden_layer_size,
                      const int num_labels,
                      const int NUM_HIDDEN_LAYERS,
                      //const MATRIX X,
                      const MATRIX Y,//X,Y should be on GPU
                      const double lambda){
    double J = 0;       // The value of the cost function will be stored in J.
    MATRIX* d_Theta, *d_Theta_grad;   // d_Theta will be a MATRIX array storing all nn_parameter   
    int currentProg = 0;
    int i = 0;
    int k = 0, index;
    int j = 0;
    int jStart, jEnd;
    int m;
    int ii,jj;
    int mallocSize;
    int err;
    MATRIX *d_delta;
    MATRIX temp;
//double* temp_grad;
int nn_paramsLength;
nn_paramsLength = (input_layer_size+1)*hidden_layer_size+
             (NUM_HIDDEN_LAYERS-1)*(hidden_layer_size+1)*hidden_layer_size+
             (hidden_layer_size+1)*num_labels;
    double tempDouble;
    double correction;
    d_Theta      = ( MATRIX* )malloc( sizeof(MATRIX)*(NUM_HIDDEN_LAYERS+1) );
    d_Theta_grad = ( MATRIX* )malloc( sizeof(MATRIX)*(NUM_HIDDEN_LAYERS+1) );
    
    d_Theta[0].data = & d_nn_params[0];
    d_Theta[0].row  = hidden_layer_size;
    d_Theta[0].col  = input_layer_size + 1;
    
    d_Theta_grad[0].data = & d_grad[0];
    d_Theta_grad[0].row  = hidden_layer_size;
    d_Theta_grad[0].col  = input_layer_size + 1;

    currentProg   = hidden_layer_size * (input_layer_size + 1) - 1; 
    // currentProg is the max index of current d_Theta.

    for ( i = 1; i <= NUM_HIDDEN_LAYERS-1; i++ ){
        d_Theta[i].data = & d_nn_params[currentProg+1];
	d_Theta[i].row  = hidden_layer_size;
 	d_Theta[i].col  = hidden_layer_size + 1;
        
	d_Theta_grad[i].data = & d_grad[currentProg+1];
	d_Theta_grad[i].row  = hidden_layer_size;
 	d_Theta_grad[i].col  = hidden_layer_size + 1;
       
        currentProg  += hidden_layer_size * (hidden_layer_size + 1);
    } 
    d_Theta[NUM_HIDDEN_LAYERS].data = & d_nn_params[currentProg+1];
    d_Theta[NUM_HIDDEN_LAYERS].row  = num_labels;
    d_Theta[NUM_HIDDEN_LAYERS].col  = hidden_layer_size + 1;

    d_Theta_grad[NUM_HIDDEN_LAYERS].data = & d_grad[currentProg+1];
    d_Theta_grad[NUM_HIDDEN_LAYERS].row  = num_labels;
    d_Theta_grad[NUM_HIDDEN_LAYERS].col  = hidden_layer_size + 1;


    
    /* a=[ones(1,m)];
       z=a;
       for kk=2:NUM_HIDDEN_LAYERS+1
          z{kk}=d_Theta{kk-1}*a{kk-1};
	  a{kk}=tanh(z{kk});
	  a{kk}=[ones(1,m);a{kk}];
   	end
    */
    //d_a = (MATRIX*)malloc( sizeof(MATRIX)* (NUM_HIDDEN_LAYERS + 2) );
    
    //d_a[0] = padOne( X );
    
    for( i=1; i<=NUM_HIDDEN_LAYERS; i++){
        temp.row = d_Theta[i-1].row;
	temp.col = d_a[i-1].col;
	mallocSize = temp.row*temp.col;
	magma_dmalloc( &(temp.data), mallocSize ); 
	//temp is a device matrix
        magma_dgemm( MagmaNoTrans      ,
	             MagmaNoTrans      , 
		     temp.row          ,
		     temp.col          ,
		     d_Theta[i-1].col  ,
		     1.0               ,
		     d_Theta[i-1].data ,
		     d_Theta[i-1].row  ,
		     d_a[i-1].data     ,
		     d_a[i-1].row      ,
                     0.0               ,
		     temp.data         ,
		     temp.row          );
  //     apply_activation_function( temp );

 /*       for( ii=0; ii<temp.row*temp.col; ii++){
	    temp.data[ii] = tanh( temp.data[ii] );
	}*/
//	d_a[i] = padOne( temp );
        magmablas_dlatanh( temp.row     ,
                           temp.col     ,
			   temp.data    , 
			   temp.row     ,
			   d_a[i].data+1,
			   d_a[i].row   );

        magma_free(temp.data);
     }

    /*d_a[NUM_HIDDEN_LAYERS+1].row = d_Theta[NUM_HIDDEN_LAYERS].row;
    d_a[NUM_HIDDEN_LAYERS+1].col = d_a[NUM_HIDDEN_LAYERS].col; 
    mallocSize = d_a[NUM_HIDDEN_LAYERS+1].row*d_a[NUM_HIDDEN_LAYERS+1].col;
    magma_dmalloc( &(d_a[NUM_HIDDEN_LAYERS+1].data) , mallocSize ); 
    */
    magma_dgemm(     MagmaNoTrans                    ,
	             MagmaNoTrans                    , 
		     d_a[NUM_HIDDEN_LAYERS+1].row    ,
		     d_a[NUM_HIDDEN_LAYERS+1].col    ,
		     d_Theta[NUM_HIDDEN_LAYERS].col  ,
		     1.0                             ,
		     d_Theta[NUM_HIDDEN_LAYERS].data ,
		     d_Theta[NUM_HIDDEN_LAYERS].row  ,
		     d_a[NUM_HIDDEN_LAYERS].data     ,
		     d_a[NUM_HIDDEN_LAYERS].row      ,
                     0.0                             ,
		     d_a[NUM_HIDDEN_LAYERS+1].data   ,
		     d_a[NUM_HIDDEN_LAYERS+1].row    );
    //my_sum ( Y , a[NUM_HIDDEN_LAYERS+1], diff, -1.0 );
    magma_dmalloc( &(temp.data) , Y.col*Y.row );
    magmablas_dlacpy( MagmaFull , 
                      Y.row     ,
		      Y.col     ,
		      Y.data    ,
		      Y.row     ,
                      temp.data ,
		      Y.row     );
    
    magmablas_dgeadd ( Y.row     ,
                       Y.col     ,
                       -1.0      ,
		       d_a[NUM_HIDDEN_LAYERS+1].data,
		       Y.row     ,
		       temp.data ,
		       Y.row     );
    
    J = magma_dnrm2 ( Y.row*Y.col ,
                      temp.data   ,
		      1           );
    J = J*J;
    J = J/2;
    magma_free(temp.data);

    //regularization
    correction = 0;
    for( i=0; i<NUM_HIDDEN_LAYERS+1; i++ ){
        //jStart = d_Theta[i].row;//7.18 modification: from col to row.
	tempDouble = magma_dnrm2( d_Theta[i].row*(d_Theta[i].col - 1),
                                  &(d_Theta[i].data[d_Theta[i].row]),
				  1 );
	tempDouble *= tempDouble;
	correction += tempDouble;
    }
    correction *= lambda/2;
    J += correction;
    d_delta = (MATRIX*)malloc( sizeof(MATRIX)*(NUM_HIDDEN_LAYERS + 2) );   
    
    magma_dmalloc( &(d_delta[NUM_HIDDEN_LAYERS+1].data) , Y.row*Y.col );
    magmablas_dlacpy( MagmaFull ,
                      Y.row     ,
                      Y.col     ,
                      d_a[NUM_HIDDEN_LAYERS+1].data    ,
                      Y.row     ,
                      d_delta[NUM_HIDDEN_LAYERS+1].data,
                      Y.row     );

    magmablas_dgeadd ( Y.row     ,
                       Y.col     ,
                       -1.0      ,
                       Y.data    ,
                       Y.row     ,
                       d_delta[NUM_HIDDEN_LAYERS+1].data ,
                       Y.row     );
    d_delta[NUM_HIDDEN_LAYERS+1].row = Y.row; 
    d_delta[NUM_HIDDEN_LAYERS+1].col = Y.col;
    magma_dgemm ( MagmaNoTrans                        ,
                  MagmaTrans                          ,
                  d_Theta_grad[NUM_HIDDEN_LAYERS].row ,
		  d_Theta_grad[NUM_HIDDEN_LAYERS].col ,
                  d_delta[NUM_HIDDEN_LAYERS+1].col    ,
                  1.0                                 ,
		  d_delta[NUM_HIDDEN_LAYERS+1].data   ,
                  d_delta[NUM_HIDDEN_LAYERS+1].row    ,
                  d_a[NUM_HIDDEN_LAYERS].data         ,
		  d_a[NUM_HIDDEN_LAYERS].row          ,
		  0.0                                 ,
		  d_Theta_grad[NUM_HIDDEN_LAYERS].data,
		  d_Theta_grad[NUM_HIDDEN_LAYERS].row );


   for( i=1; i<=NUM_HIDDEN_LAYERS; i++ ){
        k = NUM_HIDDEN_LAYERS - i;
	d_delta[k+1].col = d_delta[k+2].col;
	d_delta[k+1].row = d_Theta[k+1].col;
        mallocSize = d_delta[k+1].col * d_delta[k+1].row;
	magma_dmalloc( &(d_delta[k+1].data) , mallocSize );
	
	magma_dgemm( MagmaTrans       ,
                     MagmaNoTrans     ,
                     d_delta[k+1].row ,
                     d_delta[k+1].col ,
                     d_Theta[k+1].row ,
                     1.0              ,
                     d_Theta[k+1].data,
                     d_Theta[k+1].row ,
                     d_delta[k+2].data+(i!=1),
                     d_delta[k+2].row ,
                     0.0              ,
                     d_delta[k+1].data,
                     d_delta[k+1].row );

        //apply_diff_activation_function( d_delta[k+1] );	
//	remove_top_row(&delta[k+1]);
        //pointwise_mult_and_apply_diff_activation( d_delta[k+1],d_a[k+1] ); 
        magmablas_dla_pmult_dtanh( d_a[k+1].row     ,
	                           d_a[k+1].col     ,
				   d_a[k+1].data    ,
				   d_a[k+1].row     ,
				   d_delta[k+1].data,
				   d_delta[k+1].row );

        magma_dgemm( MagmaNoTrans          ,
                     MagmaTrans            ,
                     d_Theta_grad[k].row   ,
                     d_Theta_grad[k].col   ,
                     d_a[k].col            ,
                     1.0                   ,
		     d_delta[k+1].data + 1 ,
		     d_delta[k+1].row      ,
                     d_a[k].data           ,
                     d_a[k].row            ,
		     0.0                   ,
		     d_Theta_grad[k].data  ,
		     d_Theta_grad[k].row   );
        // regularization term.
        magmablas_dgeadd( d_Theta_grad[k].row                        ,
	                  d_Theta_grad[k].col - 1                    ,
			  lambda                                     ,
			  d_Theta[k].data + d_Theta[k].row           ,
			  d_Theta[k].row                             ,
			  d_Theta_grad[k].data + d_Theta_grad[k].row ,
			  d_Theta_grad[k].row );
	                  
    }	
	

         
     
    // free  everything    
   /* for( i=0; i<NUM_HIDDEN_LAYERS+2; i++){
        magma_free(d_a[i].data);
    }*/ 
    for( i=1; i<NUM_HIDDEN_LAYERS+2; i++){
        magma_free(d_delta[i].data);
    }
    free(d_Theta);
    free(d_Theta_grad);
    free(d_delta);
    //free(d_a);
    return J;
}


double innerProduct (double* v1,double* v2, int length){
    int i;
    double result = 0;
    for( i=0; i<length; i++){
        result += v1[i]*v2[i];
    }
    return result;
}


//v1=alpha * v2
void vectorAssignment (double *v1, double *v2, int length, double alpha){
    int i;

    for( i=0; i<length; i++){
        v1[i] = alpha * v2[i];
    }

    return ;
}

double my_min(double x, double y){
    if ( x>y ){ return y;}
    else { return x;}

}
double my_max(double x, double y){
    if ( x>y ){ return x; } 
    else { return y; }
}
/*******************************************************
 * The fmincg() minimizes the costFunction(),the nn_params will be finally 
 * modified. Return the ultimate value of the costFunction.
 **********************************************************/

double fmincg (       double* d_nn_params,
                      double (*cost)(double*,double*),
                      const int maxIter,
		      const int nn_paramsLength){
    int length = maxIter;
    
    double RHO   = 0.01,
           SIG   = 0.5,
	   INT   = 0.1,
	   EXT   = 3.0,
	   MAX   = 20.0,
           RATIO = 100.0,
           red   = 1.0;
    
    int        i = 0,
       ls_failed = 0;
    
    double *d_df0, *d_df1, *d_df2, *d_df3, f0, f1, f2, f3;
    double *d_s;
    double *d_nn_params0;
    double d1, d2, d3;
    double z1, z2, z3;
    double M , limit, A, B;
    int    ii, jj, kk, success;
    double alpha;
    double returnValue;
    /*d_df0        = (double*) malloc(sizeof(double)*nn_paramsLength);
    
    d_df1        = (double*) malloc(sizeof(double)*nn_paramsLength);

    df2        = (double*) malloc(sizeof(double)*nn_paramsLength);

    df3        = (double*) malloc(sizeof(double)*nn_paramsLength);

    s          = (double*) malloc(sizeof(double)*nn_paramsLength);
  
    nn_params0 = (double*) malloc(sizeof(double)*nn_paramsLength);

    tmp        = (double*) malloc(sizeof(double)*nn_paramsLength);
    */
    magma_dmalloc( &d_df0,nn_paramsLength );
    magma_dmalloc( &d_df1,nn_paramsLength );
    magma_dmalloc( &d_df2,nn_paramsLength );
    magma_dmalloc( &d_df3,nn_paramsLength );
    magma_dmalloc( &d_s  ,nn_paramsLength );
    magma_dmalloc( &d_nn_params0,nn_paramsLength );
    /*f1  = costFunction (  d_df1,
                          nn_params,
                          input_layer_size,
                          hidden_layer_size,
                          num_labels,
                          NUM_HIDDEN_LAYERS,
                          X,
                          Y,
                          lambda); 
    */
    f1 = (*cost) (d_nn_params, d_df1);
    //s=-d_df1;
    magma_dcopy( nn_paramsLength,
                 d_df1          ,
		 1              ,
		 d_s            ,
		 1              );
    magma_dscal( nn_paramsLength,
                 -1.0           ,
		 d_s            ,
		 1              );
    //d1=-s'*s;
    d1 = magma_dnrm2(nn_paramsLength,
                     d_s            ,
		     1              );
    d1 *= d1;
    d1 = -d1;

    z1 = red/(1-d1);
    
    while( i < length ){
        i += ( length>0 );       
        
	//nn_params0=nn_params; 
	//f0=f1; 
	//d_df0=d_df1
	//nn_params += z1*s 
	f0 = f1;
        magma_dcopy (nn_paramsLength,
	             d_nn_params    ,
		     1              ,
		     d_nn_params0   ,
		     1              );
        magma_dcopy (nn_paramsLength,
	             d_df1          ,
		     1              ,
		     d_df0          ,
		     1              );
        magma_daxpy (nn_paramsLength,
	             z1             ,
		     d_s            ,
		     1              ,
                     d_nn_params    ,
		     1              );
         f2 = (*cost) ( d_nn_params , d_df2 );
	 i += (length<0);
	 d2 = magma_ddot( nn_paramsLength,
	                  d_df2          ,
			  1              ,
			  d_s            , 
			  1              );
         
	 f3 = f1; d3 = d1; z3 = -z1;
         
	 if (length > 0){
	     M = MAX;
	 }else{
	     M = my_min( MAX , (double) (-length - i) );
	 }

         success = 0;
	 limit = -1.0;

	 while (1){
             while(  ( (f2>f1+z1*RHO*d1) || (d2>-SIG*d1) ) && (M>0)  ){
	         
		 limit = z1;
		 if (f2 > f1){
		     z2 = z3 - (0.5*d3*z3*z3)/(d3*z3+f2-f3);
		 }else{
                     A = 6*(f2-f3)/z3 + 3*(d2+d3) ;
		     B = 3*(f3-f2) - z3*(d3+2*d2);
		     z2= (sqrt(B*B - A*d2*z3*z3)-B)/A;
		 }
	         
		 z2 = my_max( my_min( z2 , INT*z3 ) , (1-INT)*z3 );
	         z1 = z1 + z2;
	     
	         magma_daxpy( nn_paramsLength,
		              z2             ,
			      d_s            ,
			      1              ,
			      d_nn_params    ,
			      1              );
	         
		 f2 = (*cost) ( d_nn_params , d_df2 );
		 M --;
		 i += ( length<0 );
		 d2 = magma_ddot( nn_paramsLength ,
		                  d_df2           ,
				  1               ,
				  d_s             ,
				  1               );
                 z3 = z3 - z2;
	     
	     }	 
             
	     if( f2 > f1+z1*RHO*d1 || d2 > -SIG*d1 ){
	         break;
	     }
	     else if( d2 > SIG*d1 ){
	         success = 1;
		 break;
	     }
	     else if( M==0 ){
	         break;
	     } 

	     A = 6*(f2-f3)/z3 + 3*(d2+d3);
	     B = 3*(f3-f2) - z3*(d3+2*d2);
	     
	     if( B*B-A*d2*z3*z3 >= 0 ){
	         z2 = -d2*z3*z3/( B + sqrt( B*B-A*d2*z3*z3) );
	     }else{
	         z2 = -d2*z3*z3/( B + sqrt(-B*B+A*d2*z3*z3) );
	     }

	     if( B*B-A*d2*z3*z3 < 0 || z2<0 ){
	         if( limit < -0.5 ){
	             z2 = z1 * (EXT-1) ;
	         }
	         else{
	             z2 = ( limit-z1 )/2 ;
	         }
	     }
             else if( limit > -0.5 && z2+z1 > limit ){
	         z2 = (limit-z1)/2;
	     }
             else if( limit < -0.5 && z2+z1 > z1*EXT){
	         z2 = z1*(EXT-1.0);
	     }
	     else if(z2 < -z3*INT){
	         z2 = -z3 * INT;
	     }
	     else if( limit > -0.5 && z2 < (limit-z1)*(1.0-INT) ){
	         z2 = (limit-z1)*(1.0-INT);
	     }

	     f3 = f2; d3 = d2 ; z3 = -z2;
	     z1 = z1 + z2; 
	     magma_daxpy( nn_paramsLength,
	                  z2             ,
			  d_s            ,
			  1              ,
			  d_nn_params    ,
			  1              );
             
	     f2 = (*cost) ( d_nn_params , d_df2 );
             M --;
	     i += (length<0);
	     d2 = magma_ddot (nn_paramsLength,
	                      d_df2          ,
			      1              ,
			      d_s            ,
			      1              );
			      

	 }

	 if(success){
	     f1 = f2;
             returnValue = f1;	     //fX = [fX' f1]'
             printf("%d | Cost: %lf\n", i , f1 );
	     // s = (df2'*df2-df1'*df2)/(df1'*df1)*s - df2;
	     alpha = (  magma_ddot( nn_paramsLength, d_df2,1,d_df2,1 )
	               -magma_ddot( nn_paramsLength, d_df1,1,d_df2,1 ) )
		     /
		     magma_ddot( nn_paramsLength, d_df1,1,d_df1,1);
	       // s = alpha*s -df2;
             magma_dscal( nn_paramsLength,
	                  alpha          ,
			  d_s            ,
			  1              );
	     magma_daxpy( nn_paramsLength,
	                  -1.0           ,
			  d_df2          ,
			  1              ,
			  d_s            ,
			  1              );
             
            //swap:tmp = df1;df1=df2;df2=tmp;d2=df1'*s;
             /*magma_dcopy( nn_paramsLength,
	                  d_df1          ,
			  1              ,
			  d_tmp          ,
			  1              );
	     magma_dcopy( nn_paramsLength,
	                  d_df2,1,
			  d_df1,1,       );
	     magma_dcopy( nn_paramsLength,
	                  d_temp,1,
			  d_df2 ,1,      );
             */
             magma_dswap( nn_paramsLength,
	                  d_df1,1,
			  d_df2,1);
	 
             d2 = magma_ddot( nn_paramsLength,
	                      d_df1,1,
			      d_s  ,1        );

	     if (d2>0){
                 magma_dcopy( nn_paramsLength,
		              d_df1,1,
			      d_s  ,1        );
	         magma_dscal( nn_paramsLength,
		              -1.0,
			      d_s ,1         );
	         d2 = -magma_ddot( nn_paramsLength,
		                  d_s,1,
				  d_s,1          );
	     }
	     z1 *= my_min( RATIO , d1/d2 );
	     d1  = d2;
	     ls_failed = 0;   
	 }else{
	     magma_dcopy( nn_paramsLength,
	                  d_nn_params0,1,
			  d_nn_params ,1   ); 
	     f1 = f0;
	     magma_dcopy( nn_paramsLength,
	                  d_df0,1,
			  d_df1,1        );
             if( ls_failed || i>abs(length) ){
	         break;
	     }
	     magma_dswap( nn_paramsLength,
	                  d_df1,1,
			  d_df2,1        );
             magma_dcopy( nn_paramsLength,
                          d_df1, 1,
			  d_s  , 1       );
	     magma_dscal( nn_paramsLength,
	                  -1.0,
			  d_s,
			  1              );
             d1 = -magma_ddot( nn_paramsLength, d_s,1,d_s,1);

	     z1 = 1/(1-d1);
	     ls_failed = 1;
    
	 }
    }
    printf("J = %lf\n", returnValue);
    magma_free( d_df0);
    magma_free( d_df1);
    magma_free( d_df2);
    magma_free( d_df3);
    magma_free( d_s );
    magma_free( d_nn_params0);
    return returnValue;   
}

